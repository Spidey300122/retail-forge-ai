import sharp from 'sharp';
import archiver from 'archiver';
import PDFDocument from 'pdfkit';
import { PassThrough } from 'stream';
import logger from '../../utils/logger.js';

const FORMATS = {
  instagram_post: { width: 1080, height: 1080, name: 'Instagram_Post' },
  facebook_feed: { width: 1200, height: 628, name: 'Facebook_Feed' },
  instagram_story: { width: 1080, height: 1920, name: 'Instagram_Story' },
  instore_display: { width: 1920, height: 1080, name: 'InStore_Display' },
};

/**
 * Helper: Optimize image buffer to target size
 */
async function optimizeToSize(buffer, width, height, targetKB = 500) {
  let quality = 90;
  let outputBuffer = null;
  let sizeKB = Infinity;

  // Initial resize
  let pipeline = sharp(buffer).resize(width, height, {
    fit: 'contain',
    background: { r: 255, g: 255, b: 255, alpha: 1 }
  });

  // Iterative compression
  while (sizeKB > targetKB && quality > 10) {
    outputBuffer = await pipeline
      .jpeg({ quality, mozjpeg: true })
      .toBuffer();
    
    sizeKB = outputBuffer.length / 1024;
    
    if (sizeKB > targetKB) {
      quality -= 10;
    }
  }

  return { buffer: outputBuffer, sizeKB, quality };
}

/**
 * Helper: Generate Compliance PDF Report
 */
function generateReport(complianceData) {
  const doc = new PDFDocument({ margin: 50, size: 'A4' });
  const stream = new PassThrough();
  doc.pipe(stream);

  // ===== HEADER =====
  doc.fontSize(26)
     .fillColor('#2563eb')
     .text('Compliance Report', { align: 'center' })
     .moveDown(0.5);

  doc.fontSize(12)
     .fillColor('#6b7280')
     .text(`Generated: ${new Date().toLocaleString()}`, { align: 'center' })
     .moveDown(2);

  // ===== STATUS BOX =====
  const statusColor = complianceData.isCompliant ? '#22c55e' : '#ef4444';
  const statusText = complianceData.isCompliant ? 'âœ“ COMPLIANT' : 'âœ— NON-COMPLIANT';
  
  doc.roundedRect(100, doc.y, 400, 80, 10)
     .fillAndStroke(statusColor, statusColor);
  
  doc.fillColor('#ffffff')
     .fontSize(20)
     .text(statusText, 100, doc.y - 65, { width: 400, align: 'center' })
     .fontSize(16)
     .text(`Score: ${complianceData.score || 0}/100`, 100, doc.y + 10, { width: 400, align: 'center' })
     .fontSize(14)
     .text(`Rules: ${complianceData.rulesPassed || 0}/${complianceData.rulesChecked || 0} passed`, 100, doc.y + 5, { width: 400, align: 'center' });
  
  doc.moveDown(3);

  // ===== VIOLATIONS =====
  if (complianceData.violations && complianceData.violations.length > 0) {
    doc.fontSize(18)
       .fillColor('#1f2937')
       .text('Issues Found:', { underline: true })
       .moveDown(1);

    complianceData.violations.forEach((violation, index) => {
      if (doc.y > 700) doc.addPage();

      doc.fontSize(13)
         .fillColor('#ef4444')
         .text(`${index + 1}. ${violation.ruleName || 'Rule Violation'}`)
         .moveDown(0.3);
      
      doc.fontSize(11)
         .fillColor('#4b5563')
         .text(violation.message, { indent: 20, width: 500 })
         .moveDown(0.3);
      
      if (violation.suggestion) {
        doc.fontSize(11)
           .fillColor('#8b5cf6')
           .text(`ðŸ’¡ ${violation.suggestion}`, { indent: 20, width: 500 });
      }
      
      doc.moveDown(0.8);
    });
  } else {
    doc.fontSize(14)
       .fillColor('#22c55e')
       .text('âœ“ No violations found!', { align: 'center' })
       .fontSize(12)
       .fillColor('#6b7280')
       .text('All compliance checks passed successfully.', { align: 'center' })
       .moveDown(2);
  }

  // ===== WARNINGS =====
  if (complianceData.warnings && complianceData.warnings.length > 0) {
    if (doc.y > 650) doc.addPage();
    else doc.moveDown(2);

    doc.fontSize(18)
       .fillColor('#1f2937')
       .text('Warnings:', { underline: true })
       .moveDown(1);

    complianceData.warnings.forEach((warning, index) => {
      if (doc.y > 700) doc.addPage();

      doc.fontSize(12)
         .fillColor('#f59e0b')
         .text(`${index + 1}. ${warning.ruleName || 'Warning'}`)
         .fontSize(11)
         .fillColor('#4b5563')
         .text(warning.message, { indent: 20, width: 500 })
         .moveDown(0.8);
    });
  }

  // ===== FOOTER =====
  const pageCount = doc.bufferedPageRange().count;
  for (let i = 0; i < pageCount; i++) {
    doc.switchToPage(i);
    doc.fontSize(10)
       .fillColor('#9ca3af')
       .text(
         `Generated by Retail Forge AI | Page ${i + 1} of ${pageCount}`,
         50,
         doc.page.height - 50,
         { align: 'center', width: doc.page.width - 100 }
       );
  }

  doc.end();
  return stream;
}

/**
 * Process Export Request
 * NOW EXPORTS: PNG (high quality) + JPEG (compressed) + PDF (compliance)
 */
export async function processExport(req, res) {
  try {
    const file = req.file; // Master image from canvas
    const { formats, complianceData, canvasSize } = req.body;
    
    if (!file) {
      return res.status(400).json({ success: false, message: 'No image data provided' });
    }

    const selectedFormats = formats ? JSON.parse(formats) : [];
    const compliance = complianceData ? JSON.parse(complianceData) : {};

    logger.info('Processing export', { 
      formats: selectedFormats.length,
      hasCompliance: !!compliance.score 
    });

    // Set headers for ZIP download
    res.set({
      'Content-Type': 'application/zip',
      'Content-Disposition': `attachment; filename="retail_forge_export_${Date.now()}.zip"`
    });

    const archive = archiver('zip', { zlib: { level: 9 } });
    archive.pipe(res);

    // 1. ADD PNG (High Quality Original)
    logger.info('Adding PNG...');
    const pngBuffer = await sharp(file.buffer)
      .png({ quality: 100, compressionLevel: 9 })
      .toBuffer();
    
    archive.append(pngBuffer, { name: 'creative.png' });

    // 2. ADD JPEG (Compressed)
    logger.info('Adding JPEG...');
    const jpegBuffer = await sharp(file.buffer)
      .jpeg({ quality: 90, mozjpeg: true })
      .toBuffer();
    
    archive.append(jpegBuffer, { name: 'creative.jpg' });

    // 3. ADD RESIZED FORMATS (if requested)
    if (selectedFormats.length > 0) {
      for (const formatKey of selectedFormats) {
        const formatSpec = FORMATS[formatKey];
        if (!formatSpec) continue;

        const { buffer } = await optimizeToSize(
          file.buffer, 
          formatSpec.width, 
          formatSpec.height
        );

        archive.append(buffer, { name: `${formatSpec.name}.jpg` });
      }
    }

    // 4. GENERATE COMPLIANCE PDF
    if (compliance && compliance.score !== undefined) {
      logger.info('Generating compliance PDF...');
      const reportStream = generateReport(compliance);
      archive.append(reportStream, { name: 'compliance_report.pdf' });
    }

    // 5. ADD METADATA
    const metadata = {
      exportDate: new Date().toISOString(),
      canvasSize: canvasSize || 'N/A',
      compliance: compliance.score ? {
        isCompliant: compliance.isCompliant,
        score: compliance.score,
        violationCount: compliance.violations?.length || 0,
        warningCount: compliance.warnings?.length || 0
      } : null,
      files: {
        png: 'creative.png',
        jpeg: 'creative.jpg',
        resizedFormats: selectedFormats.map(f => FORMATS[f]?.name).filter(Boolean),
        pdf: compliance.score ? 'compliance_report.pdf' : null
      }
    };
    
    archive.append(JSON.stringify(metadata, null, 2), { name: 'metadata.json' });

    // Finalize
    await archive.finalize();
    logger.info('âœ… Export package complete');

  } catch (error) {
    logger.error('Export failed', error);
    if (!res.headersSent) {
      res.status(500).json({ success: false, message: error.message });
    }
  }
}